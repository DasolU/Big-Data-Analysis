<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-04-16T17:14:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dasol Yoo</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Dasol Yoo</name></author><entry><title type="html">Sort</title><link href="http://localhost:4000/algorithm/2021/04/16/sort.html" rel="alternate" type="text/html" title="Sort" /><published>2021-04-16T00:00:00+09:00</published><updated>2021-04-16T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2021/04/16/sort</id><content type="html" xml:base="http://localhost:4000/algorithm/2021/04/16/sort.html">&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;
&lt;p&gt;저는 숫자를 다루는 일을 했다보니 다른 알고리즘보다 정렬 함수에 상대적으로 익숙한 편이었습니다.&lt;/p&gt;

&lt;p&gt;그렇지만 결과가 나오는 방법을 기억하고 사용만해왔고, 어떻게 데이터를 정렬해주는지는 이해한 적은 한 번도 없었습니다.&lt;/p&gt;

&lt;p&gt;책을 읽다보니 정렬 알고리즘에도 다양한 종류가 있고 알고리즘마다 시간 복잡도와 사용 상황이 다르더라구요.&lt;/p&gt;

&lt;p&gt;효율적인 알고리즘 작성을 위해서 다양한 정렬 알고리즘을 이해하고, 주어진 데이터 상황에 알맞은 알고리즘을 사용하도록 해봅시다!&lt;/p&gt;

&lt;h2 id=&quot;quick-sort&quot;&gt;Quick Sort&lt;/h2&gt;

&lt;p&gt;퀵 정렬은 하나의 파일을 기준값(Pivot, 피봇)보다 작은 원소들과 큰 원소들로 &lt;strong&gt;분할&lt;/strong&gt;하고, 기준값 왼쪽에 는 작은 원소들을 오른쪽에는 큰 원소들을 &lt;strong&gt;정렬&lt;/strong&gt;하는 방법입니다. 기준값을 기준으로 더이상 분할할 것이 없을 때까지 반복합니다.&lt;/p&gt;

&lt;h3 id=&quot;divide--conquer&quot;&gt;Divide &amp;amp; Conquer&lt;/h3&gt;

&lt;p&gt;분할 정복 방법이란 문제의 크기를 줄이기 위해 가장 간단한 기본 단계를 &lt;a href=&quot;https://dasolu.github.io/algorithm/2021/04/15/recursion.html&quot;&gt;재귀&lt;/a&gt;방법으로 반복해서 답을 찾는 방법입니다.&lt;/p&gt;

&lt;h4 id=&quot;구현&quot;&gt;구현&lt;/h4&gt;

&lt;p&gt;분할 정복 구현 방법은 두 가지만 기억하면 됩니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;기본 단계 만들기: 해결 가능한 가장 간단한 문제를 생각하고 구현하기.
    &lt;ul&gt;
      &lt;li&gt;배열을 다루는 재귀 함수를 만들 때, 보통 기본 단계는 원소의 개수가 0 또는 1인 배열입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;재귀 함수 사용해서 주어진 문제가 기본 단계가 될 때까지 나누어 작게 만들기.
    &lt;ul&gt;
      &lt;li&gt;재귀 함수를 호출할 때마다 호출의 대상(예시&amp;gt; 배열)의 크기가 점점 작아지도록 구현합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;

&lt;p&gt;한 list에 있는 원소들을 모두 더하려고 할때 for문을 사용하는 방법을 다음과 같이 사용할 수 있지만,&lt;/p&gt;

&lt;p&gt;이때 분할 정복 방법을 다음처럼 사용한다면 재귀함수를 호출할 때마다 호출되는 array의 크기를 줄일 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#기본 단계
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 우선 임의로 0으로 설정했지만, 원래는 기준 원소를 무작위로 선택합니다.
&lt;/span&gt;        								 &lt;span class=&quot;c1&quot;&gt;# 사실은 pivot 값에 따라서 평균 O(nlog2n)에서 최대 O(n^2)까지 정렬 속도가 달라집니다.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;less&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;great&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;less&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;great&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;Insertion Sort&lt;/h2&gt;

&lt;p&gt;삽입 정렬은 &lt;strong&gt;이미 순서화된 파일&lt;/strong&gt;에 새로운 레코드를 순서에 맞게 정렬하는 방법이며, 앞의 n-1개의 데이터와 n번째 데이터를 비교해서 n번째 데이터가 최솟값이면 첫 번째 위치로 보내는 방법을 반복합니다.&lt;/p&gt;

&lt;h2 id=&quot;selection-sort&quot;&gt;Selection Sort&lt;/h2&gt;

&lt;p&gt;선택 정렬은 n개의 레코드 중에 최솟값을 찾아 첫 번째 위치로 보내고, 나머지 n-1개 데이터에서 최솟값을 찾아 두 번째 위치에 놓는 방법입니다.&lt;/p&gt;

&lt;h2 id=&quot;bubble-sort&quot;&gt;Bubble Sort&lt;/h2&gt;

&lt;p&gt;버블 정렬은 &lt;strong&gt;인접한 두 개의 레코드&lt;/strong&gt; 즉, n-1번째와 n번째 레코드를 비교하여 크기에 따라 레코드 위치를 바꾸는 과정을 반복하는 방법입니다.&lt;/p&gt;

&lt;h2 id=&quot;heap-sort&quot;&gt;Heap Sort&lt;/h2&gt;

&lt;p&gt;힙 정렬은 전 이진 트리(complete binary tree)를 heap tree로 변환하여 정렬하는 방법입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;변환 방법&lt;/p&gt;

    &lt;p&gt;자식 노드와 부모 노드 중 큰 것을 위로 올려서 모든 트리에서 만족하게 변환을 반복한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-way-merge-sort&quot;&gt;2-Way Merge Sort&lt;/h2&gt;

&lt;p&gt;2-Way 합병 정렬은 이미 정렬된 2개의 파일을 한 개의 파일로 합병하는 정렬 방식입니다.&lt;/p&gt;</content><author><name>Dasol Yoo</name></author><category term="Algorithm" /><category term="Algorithm" /><summary type="html">필요성 저는 숫자를 다루는 일을 했다보니 다른 알고리즘보다 정렬 함수에 상대적으로 익숙한 편이었습니다.</summary></entry><entry><title type="html">Data Analyst? Data Engineer? Data Scientist?</title><link href="http://localhost:4000/career/2021/04/15/data-analyst-engineer-scientist.html" rel="alternate" type="text/html" title="Data Analyst? Data Engineer? Data Scientist?" /><published>2021-04-15T00:00:00+09:00</published><updated>2021-04-15T00:00:00+09:00</updated><id>http://localhost:4000/career/2021/04/15/data-analyst-engineer-scientist</id><content type="html" xml:base="http://localhost:4000/career/2021/04/15/data-analyst-engineer-scientist.html">&lt;p&gt;데이터를 분석하는 일을 하고 싶은데 관련 직무가 정말 많죠.&lt;br /&gt;
나만의 커리어를 쌓아가기 위해서 직무별 특징을 이해하고 필요 역량을 살펴볼게요. &lt;br /&gt;
각종 채용 공고를 보고 각 직무별 요구하는 job skills를 정리해봤습니다.&lt;/p&gt;

&lt;h2 id=&quot;data-analyst&quot;&gt;Data Analyst&lt;/h2&gt;
&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;
&lt;p&gt;Data-driven 의사결정을 내릴 수 있도록 정량적 수치와 분석 결과를 제공하는 사람&lt;/p&gt;
&lt;h3 id=&quot;하는-일&quot;&gt;하는 일&lt;/h3&gt;
&lt;p&gt;서비스에서 발생하는 Raw Data들을 정제/가공/적재하며, &lt;br /&gt;
회사 구성원에게 Insight가 전달될 수 있도록 대시보드 및 리포트를 구성&lt;/p&gt;
&lt;h3 id=&quot;skill&quot;&gt;Skill&lt;/h3&gt;
&lt;p&gt;필수 역량&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모바일 서비스 데이터 분석 방법(LTV, AARRR, Cohort, Funnel 등)에 대한 이해&lt;/li&gt;
  &lt;li&gt;SQL을 사용한 Raw Data 핸들링 역량&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우대 역량&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;통계, 예측 모델링 지식&lt;/li&gt;
  &lt;li&gt;데이터 시각화(Tableau, Grafana 등)에 대한 경험&lt;/li&gt;
  &lt;li&gt;Data Warehouse 구축 지식이나 경험&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;data-engineer&quot;&gt;Data Engineer&lt;/h2&gt;
&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;
&lt;p&gt;효율적인 데이터환경을 함께 만드는 사람&lt;/p&gt;

&lt;h3 id=&quot;하는-일-1&quot;&gt;하는 일&lt;/h3&gt;
&lt;p&gt;Hadoop-Ecosystem에서 데이터마트를 설계하고 Data Workflow개발 및 자동화 업무를 수행&lt;br /&gt;
효율적인 데이터 활용 및 데이터거버넌스와 관련된 데이터 도구들을 개발&lt;/p&gt;

&lt;h3 id=&quot;skill-1&quot;&gt;Skill&lt;/h3&gt;
&lt;p&gt;필수 역량&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Hadoop-Ecosystem, Database, Data Warehouse에 대한 기본적인 이해&lt;/li&gt;
  &lt;li&gt;데이터마트를 주도적으로 설계 및 구축하고 운영한 경험&lt;/li&gt;
  &lt;li&gt;복잡하거나 반복적인 문제를 데이터모델을 이용하여 단순화, 자동화하여 해결한 경험&lt;/li&gt;
  &lt;li&gt;SQL상급, Python중급 정도의 기술역량&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우대 역량&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AARRR모델과 관련된 데이터처리 경험&lt;/li&gt;
  &lt;li&gt;데이터거버넌스 관련 도구 개발, Airflow 운영 및 트러블슈팅, 웹개발(React)경험&lt;/li&gt;
  &lt;li&gt;kubernetes 활용경험&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;data-scientist&quot;&gt;Data Scientist&lt;/h2&gt;
&lt;h3 id=&quot;정의-2&quot;&gt;정의&lt;/h3&gt;
&lt;p&gt;데이터에 대한 깊이 있는 분석을 기반으로 서비스와 직/간접적으로 연결될 수 있는 아이디어 도출, 모델 개발 및 모듈화를 수행&lt;/p&gt;
&lt;h3 id=&quot;하는-일-2&quot;&gt;하는 일&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 분석 과정에서 다양한 Data Mining 및 Machine Learning/Deep Learning 기술들을 활용&lt;/li&gt;
  &lt;li&gt;실시간, 대용량, 복잡한 데이터와 비즈니스 상황에 적합한 가공/분석 기법을 개발하고 제언하며, 기존의 기술들에 대해서도 최적화/개선을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;skill-2&quot;&gt;Skill&lt;/h3&gt;
&lt;p&gt;필수 역량&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서비스 환경의 데이터를 이용한 모델 개발 및 적용 경험&lt;/li&gt;
  &lt;li&gt;Python, R, Scala, Java, SQL 등 데이터를 분석하고 모델링 할 수 있는 하나 이상의 개발 언어&lt;/li&gt;
  &lt;li&gt;통계, Machine Learning/Deep Learning에 대한 이해와 목적을 달성하기 위한 모형 및 데이터 선택에 대한 분석 경험&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우대 역량&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Hadoop이나, Spark, Hive 같은 빅데이터 분석 플랫폼 사용 경험과 대용량 데이터 분산 처리에 대한 이해&lt;/li&gt;
  &lt;li&gt;고객과 서비스에 대한 고민을 데이터와 연결 지어 생각하시고, 적극적으로 분석하고 새로운 가치를 발굴해 나간 경험&lt;/li&gt;
  &lt;li&gt;적극적이고 효율적인 커뮤니케이션을 통해서 개발된 결과를 비즈니스와 연결하시거나 인사이트를 제공하여 의사결정에 기여한 경험&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dasol Yoo</name></author><category term="Career" /><category term="Career" /><summary type="html">데이터를 분석하는 일을 하고 싶은데 관련 직무가 정말 많죠. 나만의 커리어를 쌓아가기 위해서 직무별 특징을 이해하고 필요 역량을 살펴볼게요. 각종 채용 공고를 보고 각 직무별 요구하는 job skills를 정리해봤습니다.</summary></entry><entry><title type="html">Data Structure Stack</title><link href="http://localhost:4000/basic/2021/04/15/data-structure-stack.html" rel="alternate" type="text/html" title="Data Structure Stack" /><published>2021-04-15T00:00:00+09:00</published><updated>2021-04-15T00:00:00+09:00</updated><id>http://localhost:4000/basic/2021/04/15/data-structure-stack</id><content type="html" xml:base="http://localhost:4000/basic/2021/04/15/data-structure-stack.html">&lt;p&gt;제 인생 첫 코딩 테스트를 보기 3일전에 Stack이란 단어를 처음 봤습니다.&lt;br /&gt;
구글링 덕분에 코딩 테스트 전에 개념을 파악할 수 있었지만  알고리즘 구현은 생소하고, queue(큐)와 헷갈립니다.&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;p&gt;Stack은 list의 &lt;strong&gt;한쪽 끝으로만 데이터의 삽입&amp;amp;삭제가 가능한&lt;/strong&gt; data structure(자료 구조)입니다.&lt;br /&gt;
Stack은 data structure 중 선형 구조(linear Structure)에 속하며, 포스트 잇을 한 장씩 쌓아올리는 것처럼 데이터를 쌓습니다.&lt;br /&gt;
따라서 데이터를 삭제할 때, 나중에 들어온 데이터를 먼저 삭제하는 방식(Last In First Out)으로 데이터를 처리합니다.&lt;/p&gt;

&lt;p&gt;즉 스택은 &lt;strong&gt;위쪽 방향으로 push(삽입)되고 실행할 때는 가장 위에 있는 것부터 제거(pop)&lt;/strong&gt; 합니다.&lt;/p&gt;

&lt;h2 id=&quot;호출-스택의-중요성&quot;&gt;호출 스택의 중요성&lt;/h2&gt;
&lt;p&gt;컴퓨터는 호출 스택이라고 불리는 스택을 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;multiply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 예시처럼 컴퓨터가 main 함수를 실행하는 경우를 생각해볼게요.  &lt;br /&gt;
우리가 main(1)이라고 명령하면 컴퓨터에서는 어떤 일이 벌어질까요?&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;먼저 multiply 함수 호출을 위해서 메모리가 할당되고 숫자 1이 메모리에 저장됩니다.&lt;/li&gt;
  &lt;li&gt;다음으로 add 함수가 호출되며 새로운 메모리가 할당되며 숫자 1이 메모리에 저장됩니다. &lt;br /&gt;
&lt;strong&gt;중요한 점은&lt;/strong&gt;, 이때 두 번째 메모리가 첫 번째 메모리의 &lt;strong&gt;위&lt;/strong&gt;에 올려지기 때문에  &lt;br /&gt;
add 함수가 먼저 실행되어 1*100 계산 결과를 반환하고 나서야 
멈춰있던 첫 번째 함수인 multiply가 실행된다는 점입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이처럼 여러 개의 함수를 호출할 때 나중에 호출한 함수의 변수를 가장 위에 저장하는 스택을 호출 스택이라 정의합니다.&lt;/p&gt;</content><author><name>Dasol Yoo</name></author><category term="Basic" /><category term="Basic" /><category term="Data Structure" /><summary type="html">제 인생 첫 코딩 테스트를 보기 3일전에 Stack이란 단어를 처음 봤습니다. 구글링 덕분에 코딩 테스트 전에 개념을 파악할 수 있었지만 알고리즘 구현은 생소하고, queue(큐)와 헷갈립니다.</summary></entry><entry><title type="html">Recursion</title><link href="http://localhost:4000/algorithm/2021/04/15/recursion.html" rel="alternate" type="text/html" title="Recursion" /><published>2021-04-15T00:00:00+09:00</published><updated>2021-04-15T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2021/04/15/recursion</id><content type="html" xml:base="http://localhost:4000/algorithm/2021/04/15/recursion.html">&lt;p&gt;구글링을 통해 이해했다고 생각했는데 막상 코딩테스트에 가면 구현이 어려우셨나요?&lt;/p&gt;

&lt;p&gt;저뿐만 아니라 많은 초보자분들이 재귀 방법에서 손에 잡힐 듯 잡히지 않는 느낌을 받는다고 합니다.&lt;/p&gt;

&lt;p&gt;그래서 저는 오늘 재귀를 확실히 이해해보려고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;
&lt;p&gt;반복문을 쓸까 재귀 함수를 쓸까?&lt;/p&gt;

&lt;p&gt;재귀를 쓴다고 항상 성능이 좋아지는건 아닙니다. 오히려 재귀 함수 호출이 반복될 때마다 스택에 정보를 저장하게 되므로 많은 메모리를 사용하게 됩니다. 스택이 너무 커질 경우에는 반복문을 사용하는 것이 더 좋습니다.&lt;/p&gt;

&lt;p&gt;하지만 &lt;strong&gt;중요한 알고리즘들 (예&amp;gt;&lt;a href=&quot;https://dasolu.github.io/basic/2021/04/16/sort.html&quot;&gt;퀵 정렬&lt;/a&gt; )에 재귀가 사용되므로 확실한 개념 이해가 필요&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 생각하는대로 손코딩을 하다보면 어느새 같은 기능을 반복해서 적는 구간이 생깁니다.&lt;br /&gt;
저는 이럴때마다 recursion(재귀)을 떠올리면서 def recursion을 정의하고 코드를 간결하게 만들려고 합니다.&lt;br /&gt;
하지만 재귀 방법 &lt;strong&gt;구현&lt;/strong&gt; 경험이 없다보니 error가 생기면서 당황할 일이 많더라구요.&lt;/p&gt;

&lt;p&gt;이번 기회에 완벽히 이해해서 앞으로 복잡한 데이터 분석 코드를 작성할 때도 재귀를 에러없이 한 번에 적용할 수 있도록 해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;p&gt;Recursion 함수는 결과를 return하기 전에 자기 자신을 호출하는 방법입니다.&lt;/p&gt;

&lt;h2 id=&quot;구현&quot;&gt;구현&lt;/h2&gt;
&lt;p&gt;재귀 함수를 작성할 때는&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.무한 반복을 멈추기 위한 기본 단계&lt;/strong&gt;와&lt;/p&gt;

&lt;p&gt;2.&lt;strong&gt;재귀 단계&lt;/strong&gt;를 넣어주면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;
&lt;p&gt;한 list에 있는 원소들을 모두 더하는 함수를 재귀 함수로 작성해봅니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#기본 단계
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;#가장 간단한 array는 더할 원소가 없는 array = []이며, 이때 합은 0입니다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;						 &lt;span class=&quot;c1&quot;&gt;#재귀 단계
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:])&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;호출-순서-이해하기&quot;&gt;호출 순서 이해하기&lt;/h2&gt;

&lt;p&gt;컴퓨터는 재귀 함수를 어떤 방식으로 처리하는 걸까요?&lt;/p&gt;

&lt;p&gt;이 질문에 답하기 위해서는 data structure(자료 구조) 중 linear structure(선형 구조)에 속하는 &lt;a href=&quot;https://dasolu.github.io/basic/2021/04/15/data-structure-stack.html&quot;&gt;stack&lt;/a&gt; (스택)에 대한 이해가 필요합니다.&lt;/p&gt;

&lt;p&gt;예시의 재귀 함수가 돌아가면 컴퓨터는 함수를 호출할 때마다 호출에 사용된 변수의 값을 메모리에 저장합니다. 이때  새로운 함수에 의한 메모리는 이전에 호출한 함수의 변수가 저장된 메모리 위에 저장되는 &lt;a href=&quot;https://dasolu.github.io/basic/2021/04/15/data-structure-stack.html&quot;&gt;호출 스택&lt;/a&gt;이 만들어집니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dasolu.github.io/basic/2021/04/15/data-structure-stack.html&quot;&gt;호출 스택&lt;/a&gt;은 한 방향, 즉 &lt;strong&gt;위쪽 방향으로 push(삽입)되고 실행할 때는 가장 위에 있는 것부터 제거(pop)&lt;/strong&gt; 합니다.&lt;/p&gt;

&lt;p&gt;우리가 예제에 있는 재귀함수인 sum([2,4,6])를 호출하면 컴퓨터는 다음과 같은 호출 스택을 만듭니다.&lt;/p&gt;

&lt;p&gt;아래에 쌓인 함수 호출들은 기본 단계를 만나기 전까지 완료되지 않고 호출 상태가 저장된 상태로 멈추게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가장 위에 있는 호출이 먼저&lt;/strong&gt; 처리되며 sum([6])이 실행되고 6을 반환합니다.&lt;/p&gt;

&lt;p&gt;그 결과 3 번째 호출은 4 + 6이 반환합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;호출 스택이 쌓여있는 모습&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3 번째 호출&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4+sum([6])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2 번째 호출&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2+sum([4,6])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 번째 호출&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;sum([2,4,6])&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;값을 반환한 3 번째 호출은 제거(pop)되며, 남은 호출 스택의 모습은 다음과 같게 됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;호출 스택이 쌓여있는 모습&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2 번째 호출&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2+sum([4,6])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 번째 호출&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;sum([2,4,6])&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;다음으로는 3 번째 호출이 반환한 4 + 6이 2번째 호출에 대입되고, 2 번째 호출은 2+(4+6)를 반환합니다.&lt;/p&gt;

&lt;p&gt;마찬가지로 1 번째 호출은  1+ (2+(4+6))를 반환하여 최종 답인 12가 구해집니다.&lt;/p&gt;</content><author><name>Dasol Yoo</name></author><category term="Algorithm" /><category term="Algorithm" /><summary type="html">구글링을 통해 이해했다고 생각했는데 막상 코딩테스트에 가면 구현이 어려우셨나요?</summary></entry><entry><title type="html">Data Structure Array &amp;amp; Linked List</title><link href="http://localhost:4000/basic/2021/04/14/data-structure-array-linked-list.html" rel="alternate" type="text/html" title="Data Structure Array &amp;amp; Linked List" /><published>2021-04-14T00:00:00+09:00</published><updated>2021-04-14T00:00:00+09:00</updated><id>http://localhost:4000/basic/2021/04/14/data-structure-array-linked-list</id><content type="html" xml:base="http://localhost:4000/basic/2021/04/14/data-structure-array-linked-list.html">&lt;p&gt;List-&amp;gt;Array-&amp;gt;List-&amp;gt;Array……&lt;br /&gt;
에러가 날때마다 영문도 모른체 데이터의 자료형을 변환하는데 급급했나요?&lt;br /&gt;
두 자료구조의 차이점을 몰라서 에러가 날때마다 적당히 자료형을 바꾸며 돌려막기한다면,&lt;br /&gt;
계산 시간과 한숨을 엄청나게 낭비하게 됩니다. &lt;br /&gt;
이제 이 답답함에서 벗어나보자구요!&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# What I did before
&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;listagain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;시작은 리스트였으나,&lt;br /&gt;
np.where을 사용해서 원하는 값의 index를 찾으려다가,&lt;br /&gt;
error 때문에 list-&amp;gt;array로 바꾸어 사용하다가,&lt;br /&gt;
array에 값을 추가하고 싶은데 list.append()가 생각나서,&lt;br /&gt;
다시 list로 바꾸어 사용해보셨나요?&lt;/p&gt;

&lt;p&gt;여러분은 아닐지 몰라도 저는 자주 그랬습니다ㅎㅎ…. &lt;br /&gt;
그래서 오늘은 다양한 Data Structure(자료 구조) 중 선형 구조(linear Structure)에 속하는 &lt;strong&gt;Array와 Linked List&lt;/strong&gt;를 비교 분석해봅니다.&lt;/p&gt;

&lt;h2 id=&quot;자료-구조-이해의-필요성&quot;&gt;자료 구조 이해의 필요성&lt;/h2&gt;
&lt;p&gt;효율적인 프로그램 작성을 목표로한다면 가장 중요한 것은 &lt;strong&gt;저장 공간의 효율성&lt;/strong&gt;과 &lt;strong&gt;실행 시간의 신속성&lt;/strong&gt;입니다 (정보처리기사 시나공 책).&lt;/p&gt;

&lt;p&gt;우리가 메모리에 여러 개의 원소를 저장하고 싶을 때, 우리는 컴퓨터에게 공간을 요청합니다.&lt;br /&gt;
Array(배열)과 linked list(연결 리스트)는 원소를 저장하는 방법입니다.&lt;/p&gt;

&lt;h2 id=&quot;array-정의&quot;&gt;Array 정의&lt;/h2&gt;
&lt;p&gt;Array(배열)는 동일한 자료형의 데이터들이 순서를 가지고 나열되어있는 집합입니다.&lt;br /&gt;
Array를 연속적인 메모리 공간에 저장됩니다.&lt;br /&gt;
따라서 길이가 N인 array를 지정하면 각 원소의 주소를 쉽게 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;
&lt;p&gt;이러한 특징 덕분에 array에 들어있는 원소들에게 순서대로 0부터 N-1까지 번호표를 붙일 수 있습니다.&lt;br /&gt;
이때 번호표를 &lt;strong&gt;index&lt;/strong&gt;라고 부르고, 번호표를 이용해서 원소들을 부를 수 있게 됩니다.&lt;br /&gt;
&lt;strong&gt;1. 메모리 이용 효율이 가장 좋다. Why? 메모리를 연속적으로 배정받기 때문.&lt;/strong&gt;  &lt;br /&gt;
&lt;strong&gt;2. 데이터에 임의 접근이 가능하다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;3. For loop처럼 원소마다 반복되는 작업을 하려 할때 적합하다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 데이터 추가가 어렵다.&lt;/strong&gt;&lt;br /&gt;
Array는 정적인 자료 구조이므로 계속해서 데이터 늘어난다면, array는 전체 원소를 저장할 새로운 메모리(장소)를 찾게됩니다.&lt;br /&gt;
만약 100개의 이름을 저장해야하지만 0부터 99까지 이어져있는 메모리(장소)가 없다면, 배열을 만들 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 데이터 삭제시 메모리가 빈 공간으로 남겨져 낭비된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Student array에 신입사원들의 이름을 가나다 순으로 담아놨다면 3번째에 위치한 신입사원의 이름은 student(2)를 사용해서 간편하게 알아낼 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기 N에 따라서 크기가 N인 1차원 배열, 크기가 NxN인2차원 배열로 부릅니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linked-list-정의&quot;&gt;Linked list 정의&lt;/h2&gt;
&lt;p&gt;Linked list는 각 &lt;strong&gt;노드&lt;/strong&gt;(data부분+ pointer부분)의 포인터에 다음 노드의 위치를 저장하여 데이터를 연결시키는 저장 방법입니다.&lt;br /&gt;
따라서 array와는 달리 데이터가 원소의 메모리를 임의의 어느 곳에나 둘 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;장점-1&quot;&gt;장점&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 새로운 노드를 쉽게 삽입&amp;amp; 삭제할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;단점-1&quot;&gt;단점&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. Array와 달리 n번째 원소를 한 번에 찾을 수 없다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;2. Array와 달리 각 노드에 data뿐만아니라 포인터 부분을 저장하므로 메모리 이용 효율이 나쁘다.&lt;/strong&gt;  &lt;br /&gt;
&lt;strong&gt;3. 데이터에 임의 접근이 불가능하다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;연산-시간-비교&quot;&gt;연산 시간 비교&lt;/h2&gt;
&lt;p&gt;Array 와 Linked list의 연산 시간을 Big O notation으로 표현한다면?&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Array&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Linked list&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;읽기&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;O(1)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;O(n)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;삽입&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;O(n)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;O(1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;삭제&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;O(1)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;O(n)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Array에서 삽입이 O(n)인 이유? 뒤에 오는 모든 원소들의 위치를 바꿔야하기 때문입니다.&lt;/p&gt;</content><author><name>Dasol Yoo</name></author><category term="Basic" /><category term="Basic" /><category term="Efficiency" /><category term="Data Structure" /><summary type="html">List-&amp;gt;Array-&amp;gt;List-&amp;gt;Array…… 에러가 날때마다 영문도 모른체 데이터의 자료형을 변환하는데 급급했나요? 두 자료구조의 차이점을 몰라서 에러가 날때마다 적당히 자료형을 바꾸며 돌려막기한다면, 계산 시간과 한숨을 엄청나게 낭비하게 됩니다. 이제 이 답답함에서 벗어나보자구요!</summary></entry><entry><title type="html">Big O Notation</title><link href="http://localhost:4000/basic/2021/04/13/big-o-notation.html" rel="alternate" type="text/html" title="Big O Notation" /><published>2021-04-13T00:00:00+09:00</published><updated>2021-04-13T00:00:00+09:00</updated><id>http://localhost:4000/basic/2021/04/13/big-o-notation</id><content type="html" xml:base="http://localhost:4000/basic/2021/04/13/big-o-notation.html">&lt;p&gt;Basic 카테고리에서는 효율적인 코드 작성을 위해서 필요한 기본 개념과 알고리즘들을 하나씩 익혀나
가겠습니다!&lt;br /&gt;
포스팅은 &lt;strong&gt;Hello Coding 그림으로 개념을 이해하는 알고리즘(아디트야 바르가바, 한빛미디어)&lt;/strong&gt; &amp;gt;책을 요약한 것입니다.&lt;/p&gt;

&lt;p&gt;저는 대학원을 입학하며 처음 코딩을 시작했습니다. &lt;br /&gt;
그 때가 2018년도 3월이니 벌써 3년전이네요.&lt;br /&gt;
학부에서 배운 내용이 아닌 새로운 세부 전공에 도전하다보니
수업이나 논문에 나오는 단어의 개념도 모를때였죠.&lt;br /&gt;
설상가상으로 첫 학기에 저를 마중나온 수업은 최신 통계 방법들을 코드로 작성해서 데이터에 적용하는 수업이었습니다.&lt;/p&gt;

&lt;p&gt;즉, 저는 Python, 코딩, 통계, 머신러닝과 연구분야에 대한 개념까지 모두 없는 말그대로 zero base 학생이었습니다.&lt;br /&gt;
다른 연구자들보다 능력이 부족한 상태로 시작하다보니 시간이 늘 모자랐습니다.&lt;br /&gt;
모든 것들을 해내기 위해서 거의 1년간은 아침에 택시를 타고 집에 들어가며 수업 과제들, 연구 미팅 준비를 하며 지냈습니다.&lt;/p&gt;

&lt;p&gt;시간이 부족했던 저는 python을 시작할 때 하나씩 배운다는 느낌보다는 빠른 구글링으로 문제를 해결하는데 급급했습니다.
결국 3년 후인 지금, 구글링을 통한 집요한 문제해결에는 누구보다 자신있지만, 자료 구조의 특징을 이해하고 알고리즘을 효율적으로 작성하는 방법에 대한 고민과 기본 지식이 부족한 상황입니다.&lt;/p&gt;

&lt;h2 id=&quot;필요성&quot;&gt;필요성&lt;/h2&gt;
&lt;p&gt;저처럼 실무 성과에 급급하며 python을 시작하셨다면 다음 그림에 익숙하실지도 모릅니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/pigeon.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 빅데이터를 다루는 일을 했으므로, 비둘기가 매우 오랫동안 목을 돌려야 날아가는 상황이 수두룩했습니다.&lt;br /&gt;
이제 저도 빠르고 효율적인 코드를 작성하는 사람이 되고 싶습니다.&lt;br /&gt;
&lt;strong&gt;Big O Notation (빅오 표기법)&lt;/strong&gt;은 &lt;strong&gt;‘알고리즘이 얼마나 빠른가? 더 나은 방법은 없을까?’&lt;/strong&gt;라는 생각에 대한 정량적인 비교를 가능하게 합니다.&lt;br /&gt;
예를 들어, &lt;strong&gt;Big O Notation&lt;/strong&gt;으로 인풋 데이터가 늘어날 때 연산 횟수가 증가하는 정도를 예측할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;p&gt;Big O Notation은 알고리즘이 얼마나 빠른지 표기하는 방법입니다.&lt;/p&gt;

&lt;p&gt;O(원하는 계산 결과 n을 만들기 위해 필요한 연산횟수) 로 표기합니다. 
이때 n은 원하는 계산 결과입니다.&lt;/p&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;
&lt;p&gt;종이에 16개의 네모칸을 만들어야한다면, n=16입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;경우 1 &lt;br /&gt;
하나씩 네모칸을 그린다면 총 16번의 연산이 필요합니다.&lt;br /&gt;
이때 Big O Notation은 $ O(n) $ 입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;경우 2&lt;br /&gt;
종이를 반씩 접는 방법으로 더 빠르게 네모칸을 만드는 경우에는,
종이를 4번 접는 것만으로 16개의 칸을 만들 수 있으므로 연산 횟수는 4입니다.
연산횟수 4를 n=16이 들어간 식으로 표현한다면 Big O Notation은
$O(log{_2}n)$ 입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1초에 10번의 연산이 가능한 경우 걸리는 시간을 계산해봅시다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;경우 1에 걸리는 시간 &lt;br /&gt;
경우 1은 16번의 연산이 필요하므로 1.6초 걸릴 것으로 예상할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;경우 2에 걸리는 시간&lt;br /&gt;
경우 2는 4번의 연산이 필요하므로 0.4초 걸릴 것으로 예상할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 우리는 Big O Notation 덕분에 만들어야하는 네모칸의 수(n)이 증가할수록 ‘경우 2’ 방법이 연산 시간을 단축해줄 것이라는 것을 예상할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;

&lt;p&gt;많이 사용하는 Big O Notation을 빠른 순서대로 나열했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$O(log n)$: 이진탐색&lt;/li&gt;
  &lt;li&gt;$O(n)$: 단순탐색&lt;/li&gt;
  &lt;li&gt;$O(n*log n)$: 퀵 정렬 (빠른)&lt;/li&gt;
  &lt;li&gt;$O(n**2)$: 선택 정렬 (느린)&lt;/li&gt;
  &lt;li&gt;$O(n!)$: (매우 느린)&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Dasol Yoo</name></author><category term="Basic" /><category term="Basic" /><category term="Efficiency" /><summary type="html">Basic 카테고리에서는 효율적인 코드 작성을 위해서 필요한 기본 개념과 알고리즘들을 하나씩 익혀나 가겠습니다! 포스팅은 Hello Coding 그림으로 개념을 이해하는 알고리즘(아디트야 바르가바, 한빛미디어) &amp;gt;책을 요약한 것입니다.</summary></entry></feed>